<!DOCTYPE html>
<html lang="cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="原文链接 在平面上放置一个带有拖尾的球体根据玩家输入移动球体控制速度和加速度限制球体位置以及让他从边缘弹开 这是关于控制角色移动的系列教程的第一部分。具体来说，我们将根据玩家输入来移动一个球体。 这个教程使用Unity 2019.2.9f1制作。在学习此教程之前，我们假定你已经完成Basic教程部分。  黏在平面上的球体   1 控制位置许多游戏都是关于一个角色必须四处走动以完成某些目标。玩家的任">
<meta property="og:type" content="article">
<meta property="og:title" content="Catlike Coding翻译——Movement 01移动球体（玩家控制）">
<meta property="og:url" content="http://yoursite.com/2020/08/27/01%E7%A7%BB%E5%8A%A8%E7%90%83%E4%BD%93%EF%BC%88%E7%8E%A9%E5%AE%B6%E6%8E%A7%E5%88%B6%EF%BC%89/index.html">
<meta property="og:site_name" content="Kelvin&#39;s Blog">
<meta property="og:description" content="原文链接 在平面上放置一个带有拖尾的球体根据玩家输入移动球体控制速度和加速度限制球体位置以及让他从边缘弹开 这是关于控制角色移动的系列教程的第一部分。具体来说，我们将根据玩家输入来移动一个球体。 这个教程使用Unity 2019.2.9f1制作。在学习此教程之前，我们假定你已经完成Basic教程部分。  黏在平面上的球体   1 控制位置许多游戏都是关于一个角色必须四处走动以完成某些目标。玩家的任">
<meta property="og:locale">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jYXRsaWtlY29kaW5nLmNvbS91bml0eS90dXRvcmlhbHMvbW92ZW1lbnQvc2xpZGluZy1hLXNwaGVyZS90dXRvcmlhbC1pbWFnZS5qcGc?x-oss-process=image/format,png#pic_center">
<meta property="og:image" content="https://catlikecoding.com/unity/tutorials/movement/sliding-a-sphere/controlling-position/linear-color-space.png">
<meta property="og:image" content="https://catlikecoding.com/unity/tutorials/movement/sliding-a-sphere/controlling-position/hierachy.png">
<meta property="og:image" content="https://catlikecoding.com/unity/tutorials/movement/sliding-a-sphere/controlling-position/orthographic-camera.png">
<meta property="og:image" content="https://catlikecoding.com/unity/tutorials/movement/sliding-a-sphere/controlling-position/no-shadows.png">
<meta property="og:image" content="https://catlikecoding.com/unity/tutorials/movement/sliding-a-sphere/controlling-position/project.png">
<meta property="og:image" content="https://catlikecoding.com/unity/tutorials/movement/sliding-a-sphere/controlling-position/game-view.png">
<meta property="og:image" content="https://catlikecoding.com/unity/tutorials/movement/sliding-a-sphere/controlling-position/sphere.png">
<meta property="og:image" content="https://catlikecoding.com/unity/tutorials/movement/sliding-a-sphere/controlling-position/trail-renderer.png">
<meta property="og:image" content="https://catlikecoding.com/unity/tutorials/movement/sliding-a-sphere/controlling-position/movement-trail.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200823225058998.gif#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200823233916940.gif#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200824002054109.gif#pic_center">
<meta property="article:published_time" content="2020-08-27T15:32:32.000Z">
<meta property="article:modified_time" content="2020-08-30T10:42:23.594Z">
<meta property="article:author" content="尽量不秃头的凯文">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jYXRsaWtlY29kaW5nLmNvbS91bml0eS90dXRvcmlhbHMvbW92ZW1lbnQvc2xpZGluZy1hLXNwaGVyZS90dXRvcmlhbC1pbWFnZS5qcGc?x-oss-process=image/format,png#pic_center">

<link rel="canonical" href="http://yoursite.com/2020/08/27/01%E7%A7%BB%E5%8A%A8%E7%90%83%E4%BD%93%EF%BC%88%E7%8E%A9%E5%AE%B6%E6%8E%A7%E5%88%B6%EF%BC%89/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'cn'
  };
</script>

  <title>Catlike Coding翻译——Movement 01移动球体（玩家控制） | Kelvin's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="تشغيل شريط التصفح">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Kelvin's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>الأرشيفات</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/27/01%E7%A7%BB%E5%8A%A8%E7%90%83%E4%BD%93%EF%BC%88%E7%8E%A9%E5%AE%B6%E6%8E%A7%E5%88%B6%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="尽量不秃头的凯文">
      <meta itemprop="description" content="种一棵树最好的时间是十年前，其次是现在。重在不辍">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kelvin's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Catlike Coding翻译——Movement 01移动球体（玩家控制）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">نُشر في</span>

              <time title="أُنشأ: 2020-08-27 23:32:32" itemprop="dateCreated datePublished" datetime="2020-08-27T23:32:32+08:00">2020-08-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">عُدل في</span>
                <time title="عُدل: 2020-08-30 18:42:23" itemprop="dateModified" datetime="2020-08-30T18:42:23+08:00">2020-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">في</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CatlikeCoding%E7%BF%BB%E8%AF%91/" itemprop="url" rel="index"><span itemprop="name">CatlikeCoding翻译</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><a target="_blank" rel="noopener" href="https://catlikecoding.com/unity/tutorials/movement/sliding-a-sphere/">原文链接</a></p>
<p><em>在平面上放置一个带有拖尾的球体</em><br><em>根据玩家输入移动球体</em><br><em>控制速度和加速度</em><br><em>限制球体位置以及让他从边缘弹开</em></p>
<p>这是关于控制角色移动的系列教程的第一部分。具体来说，我们将根据玩家输入来移动一个球体。</p>
<p>这个教程使用Unity 2019.2.9f1制作。在学习此教程之前，我们假定你已经完成<a target="_blank" rel="noopener" href="https://catlikecoding.com/unity/tutorials/basics/">Basic教程</a>部分。</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jYXRsaWtlY29kaW5nLmNvbS91bml0eS90dXRvcmlhbHMvbW92ZW1lbnQvc2xpZGluZy1hLXNwaGVyZS90dXRvcmlhbC1pbWFnZS5qcGc?x-oss-process=image/format,png#pic_center" height=50% width=50%>
<center><font size=2 color=gray>黏在平面上的球体</font></center>
<br/>

<h1 id="1-控制位置"><a href="#1-控制位置" class="headerlink" title="1 控制位置"></a><font size=4 color=gray>1</font> 控制位置</h1><p>许多游戏都是关于一个角色必须四处走动以完成某些目标。玩家的任务是引领角色。动作游戏让你通过按键或转动操纵杆来控制角色。点按游戏让你指示目标位置，角色会自动移动到那里。编程游戏让你写指令，让角色执行。如此等等。<br>在这个系列教程里，我们会专注于如何控制一个在3D动作游戏里的角色。我们会先从简单的部分开始：在一个小的、平面的矩形上移动球体。一旦我们掌握了这一点，我们在将来会让它变得更复杂。<br><br/></p>
<h2 id="1-1-设置场景"><a href="#1-1-设置场景" class="headerlink" title="1.1 设置场景"></a><font size=4 color=gray>1.1</font> 设置场景</h2><p>我们从一个新的默认3D场景开始。目前我们不需要Pakage Manager里的任何东西，当然你可以根据自己的需要使用渲染管线。<br>我经常使用linear色彩空间，你可以在Edit/Project Settings/Player/Other Settings里进行配置。</p>
<center><img src="https://catlikecoding.com/unity/tutorials/movement/sliding-a-sphere/controlling-position/linear-color-space.png" height=50% width=50%></center>
<center><font size=2 color=gray>Linear色彩空间</font></center>
<br/>
默认的SampleScene场景有一个照相机和平行光，我们保留这两个。创建一个Plane代表地面，加上一个Sphere，都放置于原点。默认的球体半径为0.5，所以设置它的Y坐标为0.5，让它看起来像是在地表。
<center><img src="https://catlikecoding.com/unity/tutorials/movement/sliding-a-sphere/controlling-position/hierachy.png" height=50% width=50%></center>
<center><font size=2 color=gray>场景层级</font></center>
<br/>

<p>我们限制自己在地面上进行2维移动，所以让我们把相机置于地面正上方往下看，以在游戏视图中获得一个良好的视野。同时设置相机的Projection模式为Orthigraphic。这样就避免了透视，让我们能观察到不失真的2D运动。</p>
<center><img src="https://catlikecoding.com/unity/tutorials/movement/sliding-a-sphere/controlling-position/orthographic-camera.png" height=50% width=50%></center>
<center><font size=2 color=gray>往下方看的正交相机</font></center>
<br/>
最后一个扰乱我们视线的是球体的阴影。依据你的Unity版本，设置灯光Shdow Type属性为None或No Shadows。

<center><img src="https://catlikecoding.com/unity/tutorials/movement/sliding-a-sphere/controlling-position/no-shadows.png" height=50% width=50%></center>
<center><font size=2 color=gray>灯光不会投射阴影</font></center>
<br/>
依据你的喜好为地面和球体创建材质。我把球设为黑色，把地面设为浅灰色。我们也会使用拖尾来可视化运动轨迹，所以也要创建一个拖尾的材质。我将为它使用一个无反射红色材质。最后，我们需要一个MovingSphere脚本来使移动生效。

<center><img src="https://catlikecoding.com/unity/tutorials/movement/sliding-a-sphere/controlling-position/project.png" height=50% width=50%></center>
<center><font size=2 color=gray>项目资源</font></center>
<br/>
脚本可以从一个空的MonoBehaviour类开始

<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MovingSphere</span> : <span class="title">MonoBehaviour</span> &#123; &#125;</span><br></pre></td></tr></table></figure>
<center><img src="https://catlikecoding.com/unity/tutorials/movement/sliding-a-sphere/controlling-position/game-view.png" height=30% width=30%></center>
<center><font size=2 color=gray>游戏视图</font></center>
<br/>
把TrairRenderer组件和我们的MovingSphere组件都加到小球上。其他保持不变。
<center><img src="https://catlikecoding.com/unity/tutorials/movement/sliding-a-sphere/controlling-position/sphere.png" height=50% width=50%></center>
<center><font size=2 color=gray>球体上的组件</font></center>

<p>把我们之前创建的Trail材质分配给<em>TrailRenderer</em>组件的材质数组中第一个也是唯一一个元素。它不用选中投射阴影，虽然这不是必要的（我们已经禁用了灯光的阴影投射）。除此之外，将<em>Width</em>从1.0减少为一个更加合理的值，比如0.1，以产生一条细线。</p>
<center><img src="https://catlikecoding.com/unity/tutorials/movement/sliding-a-sphere/controlling-position/trail-renderer.png" height=50% width=50%></center>
<center><font size=2 color=gray>拖尾渲染组件</font></center>
<br/>
虽然我们还没有写任何移动代码，我们可以预览一下它的样子，进入Play模式，然后在Scene窗口拖拽球体即可。
<center><img src="https://catlikecoding.com/unity/tutorials/movement/sliding-a-sphere/controlling-position/movement-trail.png" height=50% width=50%></center>
<center><font size=2 color=gray>移动产生的拖尾</font></center>
<br/>

<h2 id="1-2-读取玩家输入"><a href="#1-2-读取玩家输入" class="headerlink" title="1.2 读取玩家输入"></a><font size=4 color=gray>1.2 </font>读取玩家输入</h2><p>为了移动球体，我们必须读取玩家输入的指令。我们会在<em>MovingSphere</em>里的<em>Update</em>方法里写这些代码。玩家输入是2D的，所以我们可以将它存在一个<em>Vector2</em>变量里。首先我们会将它的X、Y分量都设为0，然后用这些值来定位球体在XZ平面的位置。因此，输入的Y分量变成了位置的Z分量。Y的位置保持为零。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MovingSphere</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Update</span> (<span class="params"></span>)</span> &#123;</span><br><span class="line">		Vector2 playerInput;</span><br><span class="line">		playerInput.x = <span class="number">0f</span>;</span><br><span class="line">		playerInput.y = <span class="number">0f</span>;</span><br><span class="line">		transform.localPosition = <span class="keyword">new</span> Vector3(playerInput.x, <span class="number">0f</span>, playerInput.y);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取玩家方向输入最简单的方法是调用<code>Input.GetAxis</code>方法，并传入轴（Axis）的名称。Unity有定义在默认情况下的横向（Horizontal）纵向（Vertical）输入轴，你可以在Project Settings的Input模块查看它们。我们把横轴的值赋给X，纵轴的值赋给Y。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">playerInput.x = Input.GetAxis(<span class="string">&quot;Horizontal&quot;</span>);</span><br><span class="line">playerInput.y = Input.GetAxis(<span class="string">&quot;Vertical&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>默认设置将这些轴链接到箭头键和WASD键。输入值同样被调整过了，所以这些的键的行为有点像手柄摇杆。你可以根据自己的喜好调整这些值，但是我保留了默认设置。<br><br/><br><img src="https://img-blog.csdnimg.cn/20200823225058998.gif#pic_center" alt="在这里插入图片描述"></p>
<center><font size=2 color=gray>使用j箭头键或WASD键</font></center><br/>

<blockquote>
<p><strong><center>**为什么不使用输入系统插件？</strong></center>**<br>你可以这么做，但是原理是一样的。我们所要做的只是获取两个轴的值。另外，在撰写本篇教程时，该插件还处于预览阶段，所以还没有正式发布和支持。</p>
</blockquote>
<h2 id="1-3-归一化输入向量"><a href="#1-3-归一化输入向量" class="headerlink" title="1.3 归一化输入向量"></a><font size=4 color=gray>1.3 </font>归一化输入向量</h2><p>当坐标轴处于静止状态时返回零，在其极值处返回- 1或1。当我们使用输入来设定球体位置时，他被约束在一个正方形内。至少，键盘输入是这样的，因为键是相互独立的。然而在摇杆系统中，两个维度是相关的，我们通常将输入限制在从原点开始，任意方向最大值为1的距离内，也即是在一个圆内。<br>手柄输入的优点是，无论方向如何，输入向量的最大长度始终为1。所以移动能在所有方向一样快。但按键不是这样，单个按键的最大值是1，但两个键都按下时，最大值是√2，也就是说对角线移动是最快的。<br>根据勾股定理，键的最大值是√2。输入轴的值定义了直角三角形两条边的长度，他们的组合向量是斜边。因此，输入向量的模为$\sqrt{x^2+y^2}$。<br>我们可以通过将输入向量除以它的模来确保它的长度不超过1。这个结果总会是单位向量的长度，除非它的初始长度是零，这种情况下，结果是没有定义的。这个过程称为归一化向量。为了达成这点，我们可以调用向量的Normalize方法，那么向量将缩放自身，如果结果未定义，则成为零向量。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">playerInput.x = Input.GetAxis(<span class="string">&quot;Horizontal&quot;</span>);</span><br><span class="line">playerInput.y = Input.GetAxis(<span class="string">&quot;Vertical&quot;</span>);</span><br><span class="line">playerInput.Normalize();</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200823233916940.gif#pic_center" alt="在这里插入图片描述"></p>
<center><font size=2 color=gray>归一化键盘输入</font></center><br/>

<h2 id="1-4-约束输入向量"><a href="#1-4-约束输入向量" class="headerlink" title="1.4 约束输入向量"></a><font size=4 color=gray>1.4 </font>约束输入向量</h2><p>始终归一化输入向量也会始终限制其位置在圆上，除非输入是无偏向的，这样我们会停在原点。在一个单独的帧中产生了原点和圆之间的线，这意味着小球会瞬间在圆和圆心上跳来跳去。<br>这样极端（1或0）的输入或许是可取的，但我们也要使圆内的所有位置都生效。我们将只在输入向量的大小超过1时才调整它。一个方便的做法是替换Normalize方法为静态方法Vector2.ClampMagnitude，并传入最大值1作为参数。结果是一个向量，要么和原输入值相同，要么缩小到所提供的最大值。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//playerInput.Normalize();</span></span><br><span class="line">playerInput = Vector2.ClampMagnitude(playerInput, <span class="number">1f</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200824002054109.gif#pic_center" alt="在这里插入图片描述"></p>
<center><font size=2 color=gray>约束键盘输入</font></center><br/>

<h1 id="2-控制加速度"><a href="#2-控制加速度" class="headerlink" title="2 控制加速度"></a><font size=4 color=gray>2 </font>控制加速度</h1><p>到目前为止，我们所做的是直接根据输入来设置球体位置。这意味着当输入向量$i$变化时，球体位置$p$也会立刻随之变化。因此$p=i$。这不是正确的运动方式，而是瞬间移动。一个更加自然的方式是把位移向量$d$和原来的位置$p_0$相加，得到下一个位置$p_1$，即$p_1=p_0+d$。</p>
<h2 id="2-1-相对运动"><a href="#2-1-相对运动" class="headerlink" title="2.1 相对运动"></a><font size=3 color=gray>2.1 </font>相对运动</h2><p>在使用$d=i$替换了$p=i$之后，我们使得输入和位置之间的影响不那么直接。这次更新移除了对位置的约束，因为它现在是相对于自身的而非原点。位置现在被一个无限迭代序列描述：$p_n$<em><del>+1</del></em>$=p_n+d$，其中$p_0$表示起始位置。</p>
<figure class="highlight c"><figcaption><span>sharp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vector3 displacement = <span class="keyword">new</span> Vector3(playerInput.x, <span class="number">0f</span>, playerInput.y);</span><br><span class="line"><span class="comment">//transform.localPosition = new Vector3(playerInput.x, 0f, playerInput.y);</span></span><br><span class="line">transform.localPosition += displacement;</span><br></pre></td></tr></table></figure>

<center><img src=https://img-blog.csdnimg.cn/20200825113913722.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyOTYzMTQw,size_16,color_FFFFFF,t_70#pic_center height=30% width=30%></center>
<center><font size=2 color=gray>相对运动</font></center>
<br/>

<h2 id="2-2-速度"><a href="#2-2-速度" class="headerlink" title="2.2 速度"></a><font size=3 color=gray>2.2 </font>速度</h2><p>我们的小球确实可以移动到任何地方，但它跑得太快了，很难控制。这是每帧都添加输入向量的结果。帧率越高，它就跑得越快。为了得到一致的结果，我们不想让帧率影响输入。如果我们输入恒定，那么位移也应该是恒定的，不管帧率会如何波动。<br>为了达到我们的目的，一帧代表了这样一段时间：前一帧和当前帧之间时间$t$变化的量，可以通过<code>Time.deltaTime</code>来访问它。这样我们的位移就是$d=it$，之前我们我们错误地假设了$t$是一个常量。<br>位移是以Unity单位来衡量的，Unity假设一单位为一米。但是我们要把输入乘以时间间隔来表述每秒的位移。为了达到米的效果，输入必须以米每秒来衡量，这样输入向量即为速度：$v=i,d=vt$。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vector3 velocity = <span class="keyword">new</span> Vector3(playerInput.x, <span class="number">0f</span>, playerInput.y);</span><br><span class="line"><span class="comment">//Vector3 displacement = new Vector3(playerInput.x, 0f, playerInput.y);</span></span><br><span class="line">Vector3 displacement = velocity * Time.deltaTime;</span><br><span class="line">transform.localPosition += displacement;</span><br></pre></td></tr></table></figure>

<center><img src=https://img-blog.csdnimg.cn/20200825142910928.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyOTYzMTQw,size_10,color_FFFFFF,t_70#pic_center height=30% width=30%></center>
<center><font size=2 color=gray>独立于帧率的速度控制</font></center>
<br/>

<h2 id="2-3-速率"><a href="#2-3-速率" class="headerlink" title="2.3 速率"></a><font size=3 color=gray>2.3 </font>速率</h2><p> 我们最大输入向量的长度为1，表示了一个一米每秒的速度。等于每小时3.6千米，约等于每小时2.24英里。那并不是很快。<br> 我们可以通过缩放输入向量来增加最大速度。缩放因子代表了最大速率，一种没有方向的速度。添加一个<code>maxFiled</code>字段，默认值是10，为它加上<code>SerializedFiled</code>属性，然后给它一个<code>Range</code>属性，就1-100吧。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">SerializeField, Range(0f, 100f)</span>]</span><br><span class="line"><span class="keyword">float</span> maxSpeed = <span class="number">10f</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong><center><font size=3 color=gray>**SerializedField 是干什么用的？</strong></center>**<br>它告诉Unity去序列化一个字段，这意味着字段会被保存并暴露在Unity编辑器中，让它能在属性栏中被更改。我们当然也能使字段公开（Public），但是通过这种方式，字段保持不受MovingSphere类以外的代码影响。</p>
</blockquote>
<p>将输入向量和最大速度相乘，得到所需的速度。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vector3 velocity = <span class="keyword">new</span> Vector3(playerInput.x, <span class="number">0f</span>, playerInput.y) * maxSpeed;</span><br></pre></td></tr></table></figure>

<center><img src=https://img-blog.csdnimg.cn/2020082515364130.png#pic_center height=30% width=50%></center>
<br/>
<img src=https://img-blog.csdnimg.cn/20200826100435462.gif#pic_center width=30%>
<center><font size=2 color=gray>最大速率设置为10</font></center>
<br/>
## <font size=3 color=gray>2.4 </font>加速度
因为我们直接操纵速度，所以它可以瞬间改变。只有输入系统所应用的过滤方法（filtering）在某种程度上减缓了变化。然而在现实中速度不可能立马改变，就像改变位置一样，它需要一点费一点力和时间。速度的变化率称为加速度$a$，也就引出了$v_n$*~+1~*$=v_n+at$，其中$v_0$是零向量。减速只是一个与当前速度相反的加速度，因此不需要特殊处理。
让我们看看如果我们用输入向量来控制加速度，而不是直接控制速度会发生什么。这需要我们持续追踪当前速度，所以把它存在一个字段里。

<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vector3 velocity;</span><br></pre></td></tr></table></figure>
<p>目前输入向量在<code>Update</code>方法里定义了加速度，但是让我现在还是保持让它乘以<code>maxSpeed</code>，暂时把它重新定义为最大加速度。然后再计算位移之前，把它计入速度。</p>
<center><img src=https://img-blog.csdnimg.cn/20200825161601204.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyOTYzMTQw,size_16,color_FFFFFF,t_70#pic_center height=30% width=30%></center>
<center><font size=2 color=gray>平滑的速度变化</font></center>
<br/>

<h2 id="2-5-期望速度"><a href="#2-5-期望速度" class="headerlink" title="2.5 期望速度"></a><font size=3 color=gray>2.5 </font>期望速度</h2><p>控制加速度，而不是直接控制速度，这样会产生更平滑的运动，但是这同样了减弱了我们对球的控制。这就像是开车对比走路。在大多数游戏里直接控制速度是由必要的，所以让我们回到那个实现方式。但是无论怎样，对加速度的应用确实产生了更平滑的动作。</p>
<center><img src=https://img-blog.csdnimg.cn/20200825164350398.png height=70% width=70%></center>
<center><font size=2 color=gray>加速度改变速度，速度转而改变位置</font></center>
<br/>

<p>  我们可以将这两种实现方法结合起来，直接控制目标速度，并对实际速度施加加速度，直到它匹配期望速度。然后我们可以通过调整球的最大加速度来调整它的灵敏度。为此要添加一个序列化字段。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">SerializeField, Range(0f, 100f)</span>]</span><br><span class="line"><span class="keyword">float</span> maxAcceleration = <span class="number">10f</span>;</span><br></pre></td></tr></table></figure>
<p>在<code>Update</code>中，我们现在使用输入向量来定义一个期望速度，不再用旧的方法来调整速度。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vector3 desiredVelocity = <span class="keyword">new</span> Vector3(playerInput.x, <span class="number">0f</span>, playerInput.y) * maxSpeed;</span><br><span class="line"><span class="comment">//velocity += acceleration * Time.deltaTime;</span></span><br></pre></td></tr></table></figure>
<p>相反，我们先通过把最大加速和$t$相乘，得到最大速度变化。这就是这帧速度改变的幅度。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vector3 desiredVelocity = <span class="keyword">new</span> Vector3(playerInput.x, <span class="number">0f</span>, playerInput.y) * maxSpeed;</span><br><span class="line"><span class="keyword">float</span> maxSpeedChange = maxAcceleration * Time.deltaTime;</span><br></pre></td></tr></table></figure>
<p>让我们首先考虑速度的X分量。如果它比期望的小，那就加上最大速度变化（即<code>maxSpeedChange</code>）。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> maxSpeedChange = maxAcceleration * Time.deltaTime;</span><br><span class="line"><span class="keyword">if</span> (velocity.x &lt; desiredVelocity.x) &#123;</span><br><span class="line">	velocity.x += maxSpeedChange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这可能导致速度过快，我们可以取增加值和期望值的最小值来预防这点。这里我们可以使用<code>Mathf.Min</code>方法。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (velocity.x &lt; desiredVelocity.x) &#123;</span><br><span class="line">	<span class="comment">//velocity.x += maxSpeedChange;</span></span><br><span class="line">	velocity.x = Mathf.Min(velocity.x + maxSpeedChange, desiredVelocity.x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或许也会可能出现速度大于期望值的情况。在这种情况下，我们减去最大变化量，然后通过<code>Mathf.Max</code>取最大变化量和期望值之间的最大值。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (velocity.x &lt; desiredVelocity.x) &#123;</span><br><span class="line">	velocity.x = Mathf.Min(velocity.x + maxSpeedChange, desiredVelocity.x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (velocity.x &gt; desiredVelocity.x) &#123;</span><br><span class="line">	velocity.x = Mathf.Max(velocity.x - maxSpeedChange, desiredVelocity.x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们也可以通过方便的<code>Marhf.MoveTowards</code>方法来实现它，传入当前值、期望值和最大允许变化值。分别对X和Z分量进行处理。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> maxSpeedChange = maxAcceleration * Time.deltaTime;</span><br><span class="line">		<span class="comment">//if (velocity.x &lt; desiredVelocity.x) &#123;</span></span><br><span class="line">		<span class="comment">//	velocity.x = Mathf.Min(velocity.x + maxSpeedChange, desiredVelocity.x);</span></span><br><span class="line">		<span class="comment">//&#125;</span></span><br><span class="line">		<span class="comment">//else if (velocity.x &gt; desiredVelocity.x) &#123;</span></span><br><span class="line">		<span class="comment">//	velocity.x = Mathf.Max(velocity.x - maxSpeedChange, desiredVelocity.x);</span></span><br><span class="line">		<span class="comment">//&#125;</span></span><br><span class="line">		velocity.x = Mathf.MoveTowards(velocity.x, desiredVelocity.x, maxSpeedChange);</span><br><span class="line">		velocity.z = Mathf.MoveTowards(velocity.z, desiredVelocity.z, maxSpeedChange);</span><br></pre></td></tr></table></figure>
<center><img src=https://img-blog.csdnimg.cn/20200826100611320.png#pic_center height=70% width=50%></center>
<br/>
<center><img src=https://img-blog.csdnimg.cn/20200826100941815.gif#pic_center height=50% width=30%></center>
<center><font size=2 color=gray>速率和加速度都设置为10</font></center>
<br/>

<p>现在，我们可以调整最大加速度，来达到平滑运动和灵敏度的理想平衡。</p>
<br/>

<h1 id="3-约束位置"><a href="#3-约束位置" class="headerlink" title="3 约束位置"></a><font size=4 color=gray>3 </font>约束位置</h1><p>除了控制小球速度，游戏另外一个大块是限制小球移动范围。我们那个简单的场景包含了一块代表地面的平面。让我们把球保持在平面上。</p>
<h2 id="3-1-待在方形里"><a href="#3-1-待在方形里" class="headerlink" title="3.1 待在方形里"></a><font size=3 color=gray>3.1 </font>待在方形里</h2><p>我们直接把允许的区域做为小球的一个可序列化字段，而非使用平面本身。我们可以使用<code>Rect</code>结构体。给它一个与平面匹配的默认值：调用它的构造方法，前两个参数传-5，后两个参数传10。这些参数定义了它的左下角和大小。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line">Rect allowedArea = <span class="keyword">new</span> Rect(<span class="number">-5f</span>, <span class="number">-5f</span>, <span class="number">10f</span>, <span class="number">10f</span>);</span><br></pre></td></tr></table></figure>
<p>在将新位置赋值给<code>transform.localPosition</code>之前，我们要先约束它的位置。所以先把位置存到一个变量里。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//transform.localPosition += displacement;</span></span><br><span class="line">Vector3 newPosition = transform.localPosition + displacement;</span><br><span class="line">transform.localPosition = newPosition;</span><br></pre></td></tr></table></figure>

<p>我们可以调用允许区域（Rect）的<code>Contains</code>方法，来检查一个点是否在它里面或在它边缘。如果不是的话，把新位置设为当前位置，即在这帧忽略移动。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vector3 newPosition = transform.localPosition + displacement;</span><br><span class="line"><span class="keyword">if</span> (!allowedArea.Contains(newPosition)) &#123;</span><br><span class="line">	newPosition = transform.localPosition;</span><br><span class="line">&#125;</span><br><span class="line">transform.localPosition = newPosition;</span><br></pre></td></tr></table></figure>
<p>当我们传递一个<code>Vector3</code>到Contains时，它检查XY坐标，这在我们的例子中是不正确的。所以传递一个新的XZ坐标的<code>Vector2</code>。</p>
<center><img src= https://img-blog.csdnimg.cn/2020082613464326.png#pic_center height=50% width=50%></center><br/>
<center><img src= https://img-blog.csdnimg.cn/20200826134852234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyOTYzMTQw,size_16,color_FFFFFF,t_70#pic_center height=50% width=40%></center>
<center><font size=2 color=gray>在平面边缘上停下</font></center>

<p>我们的小球再也无法逃出去了，当它尝试这么做时就会停下来。大现在结果是不稳定的，因为在它一些帧中忽略了移动，但我们将很快处理这个问题。在此之前，要注意的是球可以一直移动，直到它站在平面边缘上。这是因为我们限制了它的位置而没有考虑它的半径。如果整个球都留在允许范围内会看起来更好。我们可以更改代码来把半径纳入考虑，但另一种选择是直接缩小可行走区域的面积。这对我们的场景已经足够了。<br>将区域的角落往上提0.5，两个维度的大小各自减1。</p>
<img src=https://img-blog.csdnimg.cn/20200826141853792.png#pic_center width=50%>
<br>
<img src=https://img-blog.csdnimg.cn/20200826142019980.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyOTYzMTQw,size_16,color_FFFFFF,t_70#pic_center width=40%>
<center><font size=2 color=gray>在触碰到平面边缘时停下</font></center>
<br>

<h2 id="3-2-精确定位"><a href="#3-2-精确定位" class="headerlink" title="3.2 精确定位"></a><font size=3 color=gray>3.2 </font>精确定位</h2><p>我们可以用限制新位置在可行走区域的方法替换忽略移动，以避免不平稳的运动。我们我可以调用<code>Math.Clamp</code>来实现这一点，传入要限制的值，和它允许的最大最小值。使用<code>xMin</code>和<code>xMax</code>属性作为X的范围，<code>yMin</code>和<code>yMax</code>属性作为Y的范围。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!allowedArea.Contains(<span class="keyword">new</span> Vector2(newPosition.x, newPosition.z))) &#123;</span><br><span class="line">	<span class="comment">//newPosition = transform.localPosition;</span></span><br><span class="line">	newPosition.x = Mathf.Clamp(newPosition.x, allowedArea.xMin, allowedArea.xMax);</span><br><span class="line">	newPosition.z = Mathf.Clamp(newPosition.z, allowedArea.yMin, allowedArea.yMax);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src=https://img-blog.csdnimg.cn/20200826153200901.gif#pic_center width=30%>
<center><font size=2 color=gray>黏在边缘上</font></center>
<br>

<h2 id="3-3-消除速度"><a href="#3-3-消除速度" class="headerlink" title="3.3 消除速度"></a><font size=3 color=gray>3.3 </font>消除速度</h2><p>小球现在表现得像是黏在边缘上一样。在抵达一条边缘时，我们会沿着边缘滑动，需要过一会儿才能从边缘脱离。这是因为小球的速度仍旧指向边缘。我们需要远离边缘的加速度来改变（速度）方向，这需要一段时间，取决于最大加速度。<br>如果我们的球体是一个小球，区域边缘是一道墙，那小球碰到墙时应该停下来。现在确实是这样的。但是如果墙突然消失了，小球将不能恢复它原来的速度。动量消失了，碰撞对小球的动能产生了损害，小球的能量在这过程中被转移。所以我们要消去碰撞边缘时的速度。但只是这样还是有可能沿着边缘滑动的，因此，只有指向该边缘方向的速度分量应被消除。<br>要把合适的速度分量设为0，我们必须检测在两个方向上、两个维度上是否都超出了界限。这时候，我们要自己限制小球的位置，同时也要做和<code>Math.Clamp</code>、<code>Contains</code>相同的检测。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//if (!allowedArea.Contains(new Vector2(newPosition.x, newPosition.z))) &#123;</span></span><br><span class="line">			<span class="comment">//newPosition.x = Mathf.Clamp(newPosition.x, allowedArea.xMin, allowedArea.xMax);</span></span><br><span class="line">			<span class="comment">//newPosition.z = Mathf.Clamp(newPosition.z, allowedArea.yMin, allowedArea.yMax);</span></span><br><span class="line">		<span class="comment">//&#125;</span></span><br><span class="line">		<span class="keyword">if</span> (newPosition.x &lt; allowedArea.xMin) &#123;</span><br><span class="line">			newPosition.x = allowedArea.xMin;</span><br><span class="line">			velocity.x = <span class="number">0f</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (newPosition.x &gt; allowedArea.xMax) &#123;</span><br><span class="line">			newPosition.x = allowedArea.xMax;</span><br><span class="line">			velocity.x = <span class="number">0f</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (newPosition.z &lt; allowedArea.yMin) &#123;</span><br><span class="line">			newPosition.z = allowedArea.yMin;</span><br><span class="line">			velocity.z = <span class="number">0f</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (newPosition.z &gt; allowedArea.yMax) &#123;</span><br><span class="line">			newPosition.z = allowedArea.yMax;</span><br><span class="line">			velocity.z = <span class="number">0f</span>;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<center><img src=https://img-blog.csdnimg.cn/20200826225650224.gif#pic_center width=50%></center>
<center><font size=2 color=gray>不再黏在边缘上</font></center>
<br>

<h2 id="3-4-反弹"><a href="#3-4-反弹" class="headerlink" title="3.4 反弹"></a><font size=3 color=gray>3.4 </font>反弹</h2><p>速度并不总是在碰撞中消除。如果我们的球是一个完美弹跳的球，它会在相应的维度上改变方向。让我们试试。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (newPosition.x &lt; allowedArea.xMin) &#123;</span><br><span class="line">			newPosition.x = allowedArea.xMin;</span><br><span class="line">			velocity.x = -velocity.x;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (newPosition.x &gt; allowedArea.xMax) &#123;</span><br><span class="line">			newPosition.x = allowedArea.xMax;</span><br><span class="line">			velocity.x = -velocity.x;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (newPosition.z &lt; allowedArea.yMin) &#123;</span><br><span class="line">			newPosition.z = allowedArea.yMin;</span><br><span class="line">			velocity.z = -velocity.z;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (newPosition.z &gt; allowedArea.yMax) &#123;</span><br><span class="line">			newPosition.z = allowedArea.yMax;</span><br><span class="line">			velocity.z = -velocity.z;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<img src=https://img-blog.csdnimg.cn/20200826231022185.gif#pic_center width=50%>
<center><font size=2 color=gray>从边缘上弹开</font></center>
<br>

<p>现在球体保留了它的动量，它只是在撞到墙时改变了方向。它确实变慢了一点，因为在反弹后它的速度不再匹配期望速度。为了得到最好的弹跳结果，玩家需要立即调整他们的输入。</p>
<h2 id="3-5-弹跳"><a href="#3-5-弹跳" class="headerlink" title="3.5 弹跳"></a><font size=3 color=gray>3.5 </font>弹跳</h2><p>我们不需要在小球反弹的时候保持全部的速度。有些东西比其他的更容易反弹。让我们通过添加一个<code>bounciness</code>字段来配置它，默认值设为0.5，范围设为0-1。这使得我们的球体可以完全弹起，或者完全不弹起，或者介于两者之间。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">SerializeField, Range(0f, 1f)</span>]</span><br><span class="line"><span class="keyword">float</span> bounciness = <span class="number">0.5f</span>;</span><br></pre></td></tr></table></figure>
<p>当碰撞边缘时，将弹性因素计入到新的速度值。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (newPosition.x &lt; allowedArea.xMin) &#123;</span><br><span class="line">			newPosition.x = allowedArea.xMin;</span><br><span class="line">			velocity.x = -velocity.x * bounciness;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (newPosition.x &gt; allowedArea.xMax) &#123;</span><br><span class="line">			newPosition.x = allowedArea.xMax;</span><br><span class="line">			velocity.x = -velocity.x * bounciness;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (newPosition.z &lt; allowedArea.yMin) &#123;</span><br><span class="line">			newPosition.z = allowedArea.yMin;</span><br><span class="line">			velocity.z = -velocity.z * bounciness;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (newPosition.z &gt; allowedArea.yMax) &#123;</span><br><span class="line">			newPosition.z = allowedArea.yMax;</span><br><span class="line">			velocity.z = -velocity.z * bounciness;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<br>
<img src = https://img-blog.csdnimg.cn/20200826231214265.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyOTYzMTQw,size_16,color_FFFFFF,t_70#pic_center width=60%>

<center><font size=2 color=gray>弹力值设为0.5</font></center>
<br>
这并不代表现实中的物理，现实中的物理要复杂得多。但是这已经看起来有点像了，已经满足了大部分游戏的的需求。而且，我们的移动也不是很精确。我们的计算只有在一个帧的运动结束时刚好到达边缘时才正确。然而现实很有可能不是这样的，这意味着我们应该立即把球移离边缘一点：首先计算剩余的时间，然后将其与相关维度中的新速度一起使用。然而，这可能会导致第二次弹跳，使事情变得更加复杂。幸运的是，为了呈现一个球体弹跳的错觉，我们并不需要那样的精度。

<p>下一个教程是<a target="_blank" rel="noopener" href="https://catlikecoding.com/unity/tutorials/movement/physics/">物理</a></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2020/08/30/CatlikeCoding%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/" rel="next" title="CatlikeCoding写在前面">
      CatlikeCoding写在前面 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          المحتويات
        </li>
        <li class="sidebar-nav-overview">
          عام
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E6%8E%A7%E5%88%B6%E4%BD%8D%E7%BD%AE"><span class="nav-number">1.</span> <span class="nav-text">1 控制位置</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E8%AE%BE%E7%BD%AE%E5%9C%BA%E6%99%AF"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 设置场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-%E8%AF%BB%E5%8F%96%E7%8E%A9%E5%AE%B6%E8%BE%93%E5%85%A5"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 读取玩家输入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-%E5%BD%92%E4%B8%80%E5%8C%96%E8%BE%93%E5%85%A5%E5%90%91%E9%87%8F"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 归一化输入向量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-%E7%BA%A6%E6%9D%9F%E8%BE%93%E5%85%A5%E5%90%91%E9%87%8F"><span class="nav-number">1.4.</span> <span class="nav-text">1.4 约束输入向量</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E6%8E%A7%E5%88%B6%E5%8A%A0%E9%80%9F%E5%BA%A6"><span class="nav-number">2.</span> <span class="nav-text">2 控制加速度</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E7%9B%B8%E5%AF%B9%E8%BF%90%E5%8A%A8"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 相对运动</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E9%80%9F%E5%BA%A6"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 速度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-%E9%80%9F%E7%8E%87"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 速率</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-%E6%9C%9F%E6%9C%9B%E9%80%9F%E5%BA%A6"><span class="nav-number">2.4.</span> <span class="nav-text">2.5 期望速度</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E7%BA%A6%E6%9D%9F%E4%BD%8D%E7%BD%AE"><span class="nav-number">3.</span> <span class="nav-text">3 约束位置</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E5%BE%85%E5%9C%A8%E6%96%B9%E5%BD%A2%E9%87%8C"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 待在方形里</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E7%B2%BE%E7%A1%AE%E5%AE%9A%E4%BD%8D"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 精确定位</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%E6%B6%88%E9%99%A4%E9%80%9F%E5%BA%A6"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 消除速度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-%E5%8F%8D%E5%BC%B9"><span class="nav-number">3.4.</span> <span class="nav-text">3.4 反弹</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-%E5%BC%B9%E8%B7%B3"><span class="nav-number">3.5.</span> <span class="nav-text">3.5 弹跳</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">尽量不秃头的凯文</p>
  <div class="site-description" itemprop="description">种一棵树最好的时间是十年前，其次是现在。重在不辍</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2</span>
          <span class="site-state-item-name">المقالات</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">التصنيفات</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">尽量不秃头的凯文</span>
</div>
  <div class="powered-by">تطبيق الموقع <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
